{"pageProps":{"projectName":"Kumquat","currentAdr":{"slug":"20240330-use-sql-for-the-query-language","package":null,"title":"Use SQL for the Query Language","status":"accepted","supersededBy":null,"tags":[],"deciders":["James Dobson","Amir Bavand"],"body":{"enhancedMdx":"\n## Context and Problem Statement\n\nHow can we represent queries over multiple Kubernetes resources in a compact fashion that allows us to express all the\nkinds of relational queries we wish to perform? How can we ensure that this representation of the queries is compact\nand easy to use, matching what the user might expect when querying Kubernetes resources?\n\n\n\n## Decision Drivers\n\n- Expressiveness: must allow users to write complex queries involving multiple Kubernetes resources.\n- Ease of use: must not require users to learn a lot of new syntax.\n- Must nicely fit the task at hand: querying Kubernetes resources.\n- Performance: it should be easy to write queries that complete in a reasonable amount of time and that do not consume\n  an undue amount of memory.\n- Ease of implementation: we should be able to PoC a working system relatively quickly, without getting bogged down in\n  the details like having to write query optimizers.\n\n\n\n## Considered Options\n\n- Option 1: Relational Algebra as AST in YAML\n- Option 2: SQL\n- Option 3: NoSQL Database\n\n\n### Option 1: Relational Algebra as AST in YAML\nOne option is to use relational algebra to express the queries.\n\nFor example, the PersistentVolume referenced by each PersistentVolumeClaim in a namespace can be found with the\nfollowing relational algebra expression:\n\n<p align=\"center\">\nùúé<sub>*pvc.spec.volumeName=pv.metadata.name*</sub>(\nùúå<sub>*pvc*</sub>(ùúé<sub>*metadata.namespace=\"default\"*</sub>(*PersistentVolumeClaim*)) ‚®Ø\nùúå<sub>*pv*</sub>(ùúé(*PersistentVolume*)))\n</p>\n\n\nSuch an expression could be represented by its AST in code:\n\n```go\nquery := query.EqualQuery{\n\tQuery: query.CrossProductQuery{\n\t\tLeft: query.SelectionQuery{\n\t\t\tKind:      \"PersistentVolumeClaim\",\n\t\t\tNamespace: \"default\",\n\t\t\tRenameAs:  \"pvc\",\n\t\t},\n\t\tRight: query.SelectionQuery{\n\t\t\tKind:      \"PersistentVolume\",\n\t\t\tRenameAs:  \"pv\",\n\t\t},\n\t},\n\tPath1: []string{\"pvc\", \"spec\", \"volumeName\"},\n\tPath2: []string{\"pv\", \"metadata\", \"name\"},\n}\n```\n\nThe AST could be represented in the YAML template as:\n\n```yaml\n...\nspec:\n  query:\n    type: eq\n    path1:\n      - pvc\n      - spec\n      - volumeName\n    path2:\n      - pv\n      - metadata\n      - name\n    query:\n      type: cross\n      left:\n        type: select\n        kind: PersistentVolumeClaim\n        namespace: default\n        renameAs: pvc\n      right:\n        type: select\n        kind: PersistentVolume\n        renameAs: pv\n...\n```\n\n\n### Option 2: SQL\nAnother option is to use SQL to represent the queries.\n\nFor example, the PersistentVolume referenced by each PersistentVolumeClaim can be found with the\nfollowing SQL expression:\n\n```sql\nSELECT persistentvolumeclaim.data AS pvc, persistentvolume.data AS pv\nFROM \"PersistentVolumeClaim.core\" AS persistentvolumeclaim\nJOIN \"PersistentVolume.core\" AS persistentvolume ON persistentvolumeclaim.data ->> '$.spec.volumeName' = persistentvolume.name\n``` \n\nThis assumes that each Kubernetes resource type is treated as a different table:\n\n\n| namespace | name | data |\n| --------- | ---- | :--- |\n| default   | pvc1 | { \"apiVersion\": \"core/v1\", \"kind\": \"PersistentVolumeClaim\", ... |\n| default   | pvc2 | { \"apiVersion\": \"core/v1\", \"kind\": \"PersistentVolumeClaim\", ... | \n**PersistentVolumeClaim.core**\n\n| namespace | name | data |\n| --------- | ---- | :--- |\n| NULL      | pv1  | { \"apiVersion\": \"core/v1\", \"kind\": \"PersistentVolume\", ... |\n| NULL      | pv2  | { \"apiVersion\": \"core/v1\", \"kind\": \"PersistentVolume\", ... | \n**PersistentVolume.core**\n\n\n### Option 3: NoSQL Database\nAn option considered was to store the resources in a NoSQL document-based database. We could not find a one with\na query language that allowed sufficiently expressive queries across multiple object collections.\n\n\n\n## Decision Outcome\n\nChosen option: \"Option 2: SQL\", because it is a compact, well-understood language that allows users of our system\nto query across multiple Kubernetes resources.\n \n\n### Positive Consequences \n\n- Less work to implement: we can use an off-the-shelf system that provides the SQL query capabilities we need.\n- Ease of use: users who are already familiar with SQL will find that their knowledge ports easily. Users who are\n  not already familiar with SQL can find a lot of reference and training material online. \n- Performance: our system will benefit from any query optimizations applied by the underlying DBMS.\n\n### Negative Consequences\n\n- Impedance mismatch: The SQL syntax does not map perfectly to our domain.\n  - The attribute list on the select statement will need to be a specific format to work with our system as intended.\n  - The Kubernetes resources are stored in a TEXT column as JSON. Most relations will have to operate on paths\n    within the JSON, which requires the use of non-standard SQL extensions that are a bit clunky to use.\n- Susceptible to DoS: users can intentionally construct queries that perform poorly and/or consume a lot of memory.\n\n\n\n## Pros and Cons of the Options\n\n### Option 1: Relational Algebra as AST in YAML\n\n- Good, because we can develop a syntax that prevents mistakes because it is suited to the task of querying\n  Kubernetes resources. \n- Good, because we can implement the syntax tree using reactive programming techniques so that it recalculates as\n  Kubernetes resource create/update/delete events occur.\n- Bad, because representing an AST in YAML is verbose and unweildy.\n\n### Option 2: SQL\n\n- Good, because SQL is compact to represent as a string in YAML.\n- Good, because SQL is relatively well-known and there are many online resources to learn.\n- Good, because we can make use of an off-the-shelf RDBMS to execute the queries.\n- Bad, because SQL is not well-suited to working with JSON data.\n- Bad, because SQL requires a certain amount of boiler-plate in the attribute list to work correctly with the rest\n  of our system.\n\n### Option 3: NoSQL Database\nWe could not find a viable system that allowed sufficiently-expressive queries.\n\nWe recognize that a viable option may be discovered in the future. Therefore, we will ensure that our system is\ndesigned to work with multiple query engines.\n\n\n"},"creationDate":"2024-09-01T18:09:42.000Z","lastEditDate":"2024-09-01T18:09:42.000Z","lastEditAuthor":"James Dobson","publicationDate":null,"file":{"relativePath":"documents/adr/20240330-use-sql-for-the-query-language.md","absolutePath":"/home/runner/work/kumquat/kumquat/documents/adr/20240330-use-sql-for-the-query-language.md"},"repository":{"provider":"github","viewUrl":"https://github.com/guidewire-oss/kumquat/blob/master/documents/adr/20240330-use-sql-for-the-query-language.md"}},"l4bVersion":"1.0.1"},"__N_SSG":true}